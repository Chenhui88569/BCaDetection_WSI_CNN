import cv2
import math
import os 
import shutil
import numpy as np

def img_sampling_labeling(input_path_WSI,input_path_mask,output_path_processed_positive
                               ,output_path_processed_negative,output_path_unprocessed_positive,output_path_unprocessed_negative):
    positive_collection = []
    negative_collection = []
    non_tissue_collection = []
    tile_size = (101, 101)
    offset = (101, 101)
    #remove and recreate directories 
    #Raw tiles, unprocessed but labelled tiles,as well as processed and labelled tiles are stored 
    if  os.path.exists(output_path_RawTile) :
        shutil.rmtree(output_path_RawTile)     
    os.makedirs(output_path_RawTile)
    if  os.path.exists(output_path_processed_positive) :
        shutil.rmtree(output_path_processed_positive)     
    os.makedirs( output_path_processed_positive)
    if  os.path.exists(output_path_processed_negative) :
        shutil.rmtree(output_path_processed_negative)     
    os.makedirs(output_path_processed_negative)
        
    if  os.path.exists(output_path_unprocessed_positive) :
        shutil.rmtree(output_path_unprocessed_positive)     
    os.makedirs( output_path_unprocessed_positive)
    if  os.path.exists(output_path_unprocessed_negative) :
        shutil.rmtree(output_path_unprocessed_negative)     
    os.makedirs(output_path_unprocessed_negative)
    
        
    for imgname in os.listdir(input_path_WSI):
        img_WSI = cv2.imread(os.path.join(input_path_WSI,imgname))
        img_mask = cv2.imread(os.path.join(input_path_mask,imgname))
        img_shape = img_WSI.shape
        for i in range(int(math.ceil(img_shape[0]/(offset[1] * 1.0)))): #height
            for j in range(int(math.ceil(img_shape[1]/(offset[0] * 1.0)))):#width
                #for each tile
                #step1. tile sampling
                cropped_img_WSI = img_WSI[offset[1]*i:min(offset[1]*i+tile_size[1], img_shape[0]), offset[0]*j:min(offset[0]*j+tile_size[0], img_shape[1])]
                cropped_img_mask = img_mask[offset[1]*i:min(offset[1]*i+tile_size[1], img_shape[0]), offset[0]*j:min(offset[0]*j+tile_size[0], img_shape[1])]
                #save plain tiles
                cv2.imwrite(output_path_RawTile + '\\'+ imgname +'_tile_'+ str(i)+"_"+ str(j)+'.png', cropped_img_WSI)
                if cropped_img_WSI is not None:#checkpoint
                    cropped_image_WSI_01 = cropped_img_WSI/255 
                    cropped_image_WSI_img_01_mean = cropped_image_WSI_01.mean()
                    cropped_image_WSI_img_01_std = cropped_image_WSI_01.std() 
                    #step2.Remove non_tissue
                    if cropped_image_WSI_img_01_mean >= 0.85  and cropped_image_WSI_img_01_std <= 0.1: #more strict 
                         non_tissue_collection.append( imgname+'_'+str(i)+"_"+ str(j))
                    else:
                        #step3.  color space transoformation : RGB to YUV
                        # normalization and standardization are achieved using imageGenerator 
                        #img_processed = ColorSpaceTransformaton_Standardization_Normalization(cropped_img_WSI)
                        img_processed = cv2.cvtColor(cropped_img_WSI,cv2.COLOR_RGB2YUV)
                         #step4. labeling according to binary mask
                        a = np.mean(cropped_img_mask[:,:,0])/255 # binary mask 0ï¼šwhite; 1: black
                        if a >= 0.55:#60% white(positive) #more slack
                            positive_collection.append( imgname+'_'+str(i)+"_"+ str(j))
                            #save to local positive folder
                            cv2.imwrite(output_path_processed_positive + '\\'+ imgname[0:-4] +'_tile_'+ str(i)+"_"+ str(j)+'.png', img_processed)
                            cv2.imwrite(output_path_unprocessed_positive + '\\'+ imgname[0:-4] +'_tile_'+ str(i)+"_"+ str(j)+'.png', cropped_img_WSI )
                         
                        else:
                             #save to negative folder
                            cv2.imwrite(output_path_processed_negative + '\\'+ imgname[0:-4] +'_tile_'+ str(i)+"_"+ str(j)+'.png', img_processed)
                            cv2.imwrite(output_path_unprocessed_negative + '\\'+ imgname[0:-4] +'_tile_'+ str(i)+"_"+ str(j)+'.png', cropped_img_WSI )
                            negative_collection.append(imgname+'_'+str(i)+"_"+ str(j)) 
                else:
                    non_tissue_collection.append(dirname+'_'+str(i)+"_"+ str(j))
    return positive_collection, negative_collection, non_tissue_collection

